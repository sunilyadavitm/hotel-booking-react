{"ast":null,"code":"import { defaultDateLib } from \"../classes/DateLib.js\";\nimport { dateMatchModifiers } from \"./dateMatchModifiers.js\";\nimport { rangeContainsDayOfWeek } from \"./rangeContainsDayOfWeek.js\";\nimport { rangeIncludesDate } from \"./rangeIncludesDate.js\";\nimport { rangeOverlaps } from \"./rangeOverlaps.js\";\nimport { isDateAfterType, isDateBeforeType, isDateInterval, isDateRange, isDatesArray, isDayOfWeekType } from \"./typeguards.js\";\n/**\n * Returns whether a range contains dates that match the given modifiers.\n *\n * ```tsx\n * const range: DateRange = {\n *   from: new Date(2021, 12, 21),\n *   to: new Date(2021, 12, 30)\n * };\n * const matcher1: Date = new Date(2021, 12, 21);\n * const matcher2: DateRange = {\n *   from: new Date(2022, 5, 1),\n *   to: new Date(2022, 5, 23)\n * };\n * rangeContainsModifiers(range, [matcher1, matcher2]); // true, since matcher1 is in the date.\n * ```\n *\n * @since 9.2.2\n * @group Utilities\n */\nexport function rangeContainsModifiers(range, modifiers, dateLib = defaultDateLib) {\n  const matchers = Array.isArray(modifiers) ? modifiers : [modifiers];\n  // Defer function matchers evaluation as they are the least performant.\n  const nonFunctionMatchers = matchers.filter(matcher => typeof matcher !== \"function\");\n  const nonFunctionMatchersResult = nonFunctionMatchers.some(matcher => {\n    if (typeof matcher === \"boolean\") return matcher;\n    if (dateLib.isDate(matcher)) {\n      return rangeIncludesDate(range, matcher, false, dateLib);\n    }\n    if (isDatesArray(matcher, dateLib)) {\n      return matcher.some(date => rangeIncludesDate(range, date, false, dateLib));\n    }\n    if (isDateRange(matcher)) {\n      if (matcher.from && matcher.to) {\n        return rangeOverlaps(range, {\n          from: matcher.from,\n          to: matcher.to\n        }, dateLib);\n      }\n      return false;\n    }\n    if (isDayOfWeekType(matcher)) {\n      return rangeContainsDayOfWeek(range, matcher.dayOfWeek, dateLib);\n    }\n    if (isDateInterval(matcher)) {\n      const isClosedInterval = dateLib.isAfter(matcher.before, matcher.after);\n      if (isClosedInterval) {\n        return rangeOverlaps(range, {\n          from: dateLib.addDays(matcher.after, 1),\n          to: dateLib.addDays(matcher.before, -1)\n        }, dateLib);\n      }\n      return dateMatchModifiers(range.from, matcher, dateLib) || dateMatchModifiers(range.to, matcher, dateLib);\n    }\n    if (isDateAfterType(matcher) || isDateBeforeType(matcher)) {\n      return dateMatchModifiers(range.from, matcher, dateLib) || dateMatchModifiers(range.to, matcher, dateLib);\n    }\n    return false;\n  });\n  if (nonFunctionMatchersResult) {\n    return true;\n  }\n  const functionMatchers = matchers.filter(matcher => typeof matcher === \"function\");\n  if (functionMatchers.length) {\n    let date = range.from;\n    const totalDays = dateLib.differenceInCalendarDays(range.to, range.from);\n    for (let i = 0; i <= totalDays; i++) {\n      if (functionMatchers.some(matcher => matcher(date))) {\n        return true;\n      }\n      date = dateLib.addDays(date, 1);\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["defaultDateLib","dateMatchModifiers","rangeContainsDayOfWeek","rangeIncludesDate","rangeOverlaps","isDateAfterType","isDateBeforeType","isDateInterval","isDateRange","isDatesArray","isDayOfWeekType","rangeContainsModifiers","range","modifiers","dateLib","matchers","Array","isArray","nonFunctionMatchers","filter","matcher","nonFunctionMatchersResult","some","isDate","date","from","to","dayOfWeek","isClosedInterval","isAfter","before","after","addDays","functionMatchers","length","totalDays","differenceInCalendarDays","i"],"sources":["C:\\Users\\pc\\Downloads\\hotel-booking-react\\node_modules\\react-day-picker\\src\\utils\\rangeContainsModifiers.ts"],"sourcesContent":["import { defaultDateLib, type DateLib } from \"../classes/DateLib.js\";\nimport type { Matcher } from \"../types/index.js\";\n\nimport { dateMatchModifiers } from \"./dateMatchModifiers.js\";\nimport { rangeContainsDayOfWeek } from \"./rangeContainsDayOfWeek.js\";\nimport { rangeIncludesDate } from \"./rangeIncludesDate.js\";\nimport { rangeOverlaps } from \"./rangeOverlaps.js\";\nimport {\n  isDateAfterType,\n  isDateBeforeType,\n  isDateInterval,\n  isDateRange,\n  isDatesArray,\n  isDayOfWeekType\n} from \"./typeguards.js\";\n\n/**\n * Returns whether a range contains dates that match the given modifiers.\n *\n * ```tsx\n * const range: DateRange = {\n *   from: new Date(2021, 12, 21),\n *   to: new Date(2021, 12, 30)\n * };\n * const matcher1: Date = new Date(2021, 12, 21);\n * const matcher2: DateRange = {\n *   from: new Date(2022, 5, 1),\n *   to: new Date(2022, 5, 23)\n * };\n * rangeContainsModifiers(range, [matcher1, matcher2]); // true, since matcher1 is in the date.\n * ```\n *\n * @since 9.2.2\n * @group Utilities\n */\nexport function rangeContainsModifiers(\n  range: { from: Date; to: Date },\n  modifiers: Matcher | Matcher[],\n  dateLib: DateLib = defaultDateLib\n): boolean {\n  const matchers = Array.isArray(modifiers) ? modifiers : [modifiers];\n\n  // Defer function matchers evaluation as they are the least performant.\n  const nonFunctionMatchers = matchers.filter(\n    (matcher) => typeof matcher !== \"function\"\n  );\n\n  const nonFunctionMatchersResult = nonFunctionMatchers.some((matcher) => {\n    if (typeof matcher === \"boolean\") return matcher;\n\n    if (dateLib.isDate(matcher)) {\n      return rangeIncludesDate(range, matcher, false, dateLib);\n    }\n\n    if (isDatesArray(matcher, dateLib)) {\n      return matcher.some((date) =>\n        rangeIncludesDate(range, date, false, dateLib)\n      );\n    }\n\n    if (isDateRange(matcher)) {\n      if (matcher.from && matcher.to) {\n        return rangeOverlaps(\n          range,\n          { from: matcher.from, to: matcher.to },\n          dateLib\n        );\n      }\n      return false;\n    }\n\n    if (isDayOfWeekType(matcher)) {\n      return rangeContainsDayOfWeek(range, matcher.dayOfWeek, dateLib);\n    }\n\n    if (isDateInterval(matcher)) {\n      const isClosedInterval = dateLib.isAfter(matcher.before, matcher.after);\n      if (isClosedInterval) {\n        return rangeOverlaps(\n          range,\n          {\n            from: dateLib.addDays(matcher.after, 1),\n            to: dateLib.addDays(matcher.before, -1)\n          },\n          dateLib\n        );\n      }\n      return (\n        dateMatchModifiers(range.from, matcher, dateLib) ||\n        dateMatchModifiers(range.to, matcher, dateLib)\n      );\n    }\n\n    if (isDateAfterType(matcher) || isDateBeforeType(matcher)) {\n      return (\n        dateMatchModifiers(range.from, matcher, dateLib) ||\n        dateMatchModifiers(range.to, matcher, dateLib)\n      );\n    }\n\n    return false;\n  });\n\n  if (nonFunctionMatchersResult) {\n    return true;\n  }\n\n  const functionMatchers = matchers.filter(\n    (matcher) => typeof matcher === \"function\"\n  );\n\n  if (functionMatchers.length) {\n    let date = range.from;\n    const totalDays = dateLib.differenceInCalendarDays(range.to, range.from);\n\n    for (let i = 0; i <= totalDays; i++) {\n      if (functionMatchers.some((matcher) => matcher(date))) {\n        return true;\n      }\n      date = dateLib.addDays(date, 1);\n    }\n  }\n\n  return false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}